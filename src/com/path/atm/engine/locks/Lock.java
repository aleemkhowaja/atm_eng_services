package com.path.atm.engine.locks;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;
import com.path.atm.engine.util.concurrent.TimerService;

/**
 * This Lock has the same basic behavior as ReentrantLock 
 * but with extended capabilities to control the validity
 * and control eviction from the pool.
 * 
 * <p> whenever an operation is executed over the lock, a validity
 * check is applied to make sure the lock is still valid else an {@link InvalidLockException}
 * is thrown
 * 
 * @author MohammadAliMezzawi
 * @param <K>
 *
 */
public class Lock<K> extends LockResource<K>{
	
	/**
	 * Reference to the internal reentrant lock
	 */
	private ReentrantLock internalLock;
	
	/**
	 * Hold the lock status
	 * ( don't add volatile , synch is handling it)
	 * 
	 */
	private LockStatus status;
	
	/**
	 * Hold the last time when the lock was requested
	 */
	private long lastAccessTime;
	
	/**
	 * Hold the time to live
	 */
	private long ttl;
	
	/**
	 * Create a lock with last access time defaulted to now
	 * @param lockKey
	 */
	public Lock(K lockKey) {
		super(lockKey);
		internalLock = new ReentrantLock();
		lastAccessTime = TimerService.getTime();
		status = LockStatus.NEW;
		ttl = Long.MAX_VALUE;
	}
	
	
	/**
	 * Create a lock with last access time defaulted to now
	 * and status equal to provided arguments
	 */
	public Lock(K lockKey, LockStatus lstatus) {
		super(lockKey);
		internalLock = new ReentrantLock();
		lastAccessTime = TimerService.getTime();
		status = lstatus;
		ttl = Long.MAX_VALUE;
	}
	
	
	/**
	 * Create a lock with last access time defaulted to now
	 * and status equal to provided arguments
	 */
	public Lock(K lockKey, long ttlVal) {
		super(lockKey);
		internalLock = new ReentrantLock();
		lastAccessTime = TimerService.getTime();
		status = LockStatus.NEW;
		ttl = ttlVal;
	}
	
	
	/**
	 * Create a lock with last access time defaulted to now
	 * and status equal to provided arguments
	 */
	public Lock(K lockKey, LockStatus lstatus, long ttlVal) {
		super(lockKey);
		internalLock = new ReentrantLock();
		lastAccessTime = TimerService.getTime();
		status = lstatus;
		ttl = ttlVal;
	}
	
	
	/**
	 * Create a lock with last access time defaulted to now
	 * and status equal to provided arguments
	 */
	public Lock(K lockKey, LockStatus lstatus, long ttlVal, long accesstime) {
		super(lockKey);
		internalLock = new ReentrantLock();
		lastAccessTime = accesstime;
		status = lstatus;
		ttl = ttlVal;
	}
	
	
    /**
     * Acquires the lock.
     *
     * <p> Check if the lock is valid , else throw an exception
     * 
     * <p>Acquires the lock if it is not held by another thread and returns
     * immediately, setting the lock hold count to one.
     *
     * <p>If the current thread already holds the lock then the hold
     * count is incremented by one and the method returns immediately.
     *
     * <p>If the lock is held by another thread then the
     * current thread becomes disabled for thread scheduling
     * purposes and lies dormant until the lock has been acquired,
     * at which time the lock hold count is set to one.
     * @throws Exception 
     * 
     * @TODO : we may need to differentiate the interrupted exception
     * generated by lock from other exception generated by thread
     */
	public void lock() throws InvalidLockException,InterruptedException {
		
		try {
			
			// try to update the internal state
			updateInternalState();
			
			// Acquire the internal lock 
			internalLock.lockInterruptibly();
			
		}catch (InvalidLockException exception) {
			// fully release the lock
			LockUtil.releaseLock(internalLock);
			
			// re-throw the exception
			throw exception;
		}
	}

	
    /**
     * Acquires the lock only if it is not held by another thread at the time
     * of invocation.
     */
	public boolean tryLock() throws InvalidLockException {
		
		try {
			
			// try to update the internal state
			updateInternalState();
			
			// Acquire the internal lock
			return internalLock.tryLock();
			
		}catch (InvalidLockException exception) {
			
			// fully release the lock
			LockUtil.releaseLock(internalLock);
			
			// re-throw the exception
			throw exception;
		}
	}
	
	
    /**
     * Acquires the lock if it is not held by another thread within the given
     * waiting time and the current thread has not been
     * {@linkplain Thread#interrupt interrupted}.
     */
	public boolean tryLock(long timeout, TimeUnit unit) 
			throws InvalidLockException,InterruptedException {
		
		try {
			
			// try to update the internal state
			updateInternalState();
			
			// Acquire the internal lock
			return internalLock.tryLock(timeout, unit);
			
		}catch (InvalidLockException exception) {
			
			// fully release the lock
			LockUtil.releaseLock(internalLock);
			
			// re-throw the exception
			throw exception;
		}
	}
	
	
    /**
     * Attempts to release this lock, if it's the owner 
     * of it and the lock was still valid.
     */
	public void unlock() throws InvalidLockException {
		
		try {
			
			/**
			 * We can't unlock a lock hold by another 
			 * thread else an IllegalMonitorStateException
			 * will be thrown.
			 * This should be the responsibility of the 
			 * force lock is case it's feasible.
			 * This mean the dev has wrongly used the lock
			 * we should blow up his code.
			 * Remove the below
			 */
			//if(! internalLock.isHeldByCurrentThread() )
			//	return;
			
			// try to update the internal state
			updateInternalState();
			
			// unlock the internal lock
			internalLock.unlock();
			
		}catch (InvalidLockException exception) {
			
			// fully release the lock
			LockUtil.releaseLock(internalLock);
			
			// re-throw the exception
			throw exception;
		}
	}
	
	
	/**
	 * Break a lock mean completely release the lock
	 * @todo we still have to implement the force release lock
	 * where a monitor thread force another thread to release a lock
	 */
	public void breakLock() {
		LockUtil.releaseLock(internalLock);	
	}
	
	
	/**
	 * Set Synchronously the last access time
	 * @param date
	 */
	public void setLastAccessTime(long time) {
		synchronized (status) {
			lastAccessTime = time;
		}
	}


	/**
	 * Mark a lock as invalid
	 */
	public void markAsInvalid() {
		synchronized (status) {
			status = LockStatus.INVALID;
		}
	}
	
	
	/**
	 * Check if the given lock is still a valid one
	 * 1- check the status
	 * 2- check the TTL
	 * @return
	 */
	public boolean checkValidity() {
		
		// Hold the control
		synchronized (status) {
			
			// if the lock is marked as invalid
			if(status.equals(LockStatus.INVALID))
				return false;
			
			System.out.println("3.0 Axs => " + getLastAccessTime());
			System.out.println("3.1 SYS => " + TimerService.getTime());
			System.out.println("3.2 BOL =>" + (lastAccessTime > 
				TimerService.getTime() - ttl));
			return lastAccessTime > 
				TimerService.getTime() - ttl;
		}
	}
	
	
	/**
	 * Extend lock life.
	 * @return
	 */
	public boolean extendLife() {
		
		// Hold the control
		synchronized (status) {
			
			// update lock status
			status = LockStatus.NEW;
			
			// update the lock info
			setLastAccessTime(TimerService.getTime());
		}
		
		return true;
	}
	
	
	/**
	 * Return a string representation of the lock.
	 */
	public String toString() {
		
		String lockInfo = "Object: %s , "
				+ "Internal Lock : { basic info => %s ,isLocked => %s , "
				+ "holdCount => %s , waitingLock => %s } , "
				+ "LockStatus => %s , last Access time => %s, ttl : %s";
		
		return String.format(lockInfo,
			super.toString(),
			internalLock.toString(),
			internalLock.isLocked(),
			internalLock.getHoldCount(),
			internalLock.getQueueLength(),
			status.toString(),
			lastAccessTime,
			ttl);
	}
	
	
	/**
	 * <p> Update the lock internal state ( life time ) 
	 * In case it fail to update life time then the lock will be marked 
	 * as invalid and an exception will be thrown
	 * 
	 * @throws Exception
	 */
	private void updateInternalState() throws InvalidLockException {
		/**
		 * Check if the lock is still valid
		 */
		synchronized (status) {
			
			if(checkValidity())
				return;
			
			// mark the lock as invalid in case it wasn't due ttl
			markAsInvalid();
			
			// throw invalid exception
			throw new InvalidLockException("Invalid lock");
		}
	}
	
	
	/**
	 * Return the last access time
	 * @return
	 */
	public long getLastAccessTime() {
		return lastAccessTime;
	}


	/**
	 * Return the lock time to live
	 * @return
	 */
	public long getTtl() {
		return ttl;
	}
}
